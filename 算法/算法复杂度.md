---
title: 算法复杂度
date: 2020-03-29 20:44:00
tags: 算法
---



# 算法复杂度

## 1.怎么分析算法复杂度

#### 一、时间复杂度

所有代码的**执行时间 T(n)** 与每行代码的**执行次数 n** 成正比.


```math
T(n)=O(f(n))
```


- T(n)：所有代码执行的总时间
- n：数据规模大小
- f(n)：每行代码执行的次数总和

----

**时间复杂度分析**

- 关注循环次数最多的一段代码
  - 通常会忽略常熟，系数等，只记录最大的一个量级即可
  - 只关注执行次数最多的一段代码即可
  
- 加法法则：总的时间复杂度等于量级最大的代码的时间复杂度
  
  - 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))
  
- 乘法法则：嵌套代码的复杂度等于嵌套代码内外复杂度的乘积
  
  - 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么 T1(n)*T2(n)=O(f(n)) * O(g(n))=O(f(n)*g(n)) 也就是说，假设T1(n)=O(n),T2(n)=O(n^2)，则有T1(n) * T2(n)=O(n^3)
  
  
  **例:**
  
  ```java
   public int getSum(int n){
          int sum=0;
          for (int i = 1; i <= n; i++) {
              sum+=i;
          }
          return sum;
          
      }
  ```
  
  结论：常量级第二行不考虑，执行次数最多的是for循环，所以时间复杂度为O(n)
  
#### 二、空间复杂度


- 空间复杂度：表示算法的**存储空间**与**数据规模**之间的增长关系

**例：**

```java
 public int getSum(int n){
        int sum=0;
        int[] a=new int[n];
        for (int i = 1; i <= a.length; i++) {
            sum+=i;
        }
        return sum;

    }
```

结论：int sum=0为常量阶，可以忽略，其余的仅int[] a=new int[n]申请了内存，所以空间复杂度为O(n)

#### 3）算法稳定性

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的

## 2.最好，最坏，平均，均摊时间复杂度

- 最好时间复杂度：最好情况的时间复杂度
- 最坏时间复杂度：最坏情况的时间复杂度
- 平均时间复杂度：将所有情况用加权平均值表示，通常没说权值默认是均分，即除以情况种数
- 均摊时间复杂度：在代码执行的所有复杂度情况中，大部分情况下时间复杂度都很低，只有极个别情况下的时间复杂度比较高，而且发生具有**前后连贯的时序关系**时，可以将个别高级别复杂度均摊到低级别复杂度上。均摊结果一般都等于**低级别复杂度**

# 3.常见的时间复杂度

![时间复杂度](算法复杂度/1.png)