---
title: 常见算法排序
date: 2020-03-29 20:44:00
tags: 算法
---


[TOC]



#  一、插入排序

**思路**

对于未排序的数据，从第1位从后往前扫描，取出元素，和前面的元素对比，若当前元素小于前一元素，则将前一元素后移，当前元素继续与前两个位置的元素比较，直到找出大于或等于的元素位置，将该元素插入到对应位置

```java
private static int[] insertSort(int[] a) {
        for (int i = 1; i < a.length; i++) {
            int temp = a[i];
            int tempIndex = i;
            while (tempIndex > 0 && temp < a[tempIndex-1]) {
                a[tempIndex] = a[tempIndex-1];
                tempIndex--;
            }
            a[tempIndex] = temp;
        }
        return a;
    }
```

![插入排序](常见算法排序/插入排序.gif)



# 个人简介

## 二、希尔(Shell )排序

**思路**

将整个待排序序列分成若干个子序列分别进行直接插入排序

- 选择一个增量Tn，其中Tn>1
- 按增量序列数n，对序列进行n趟排序
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。

**代码**

<s>待补充</s>



**动图**

 ![希尔排序](常见算法排序/希尔排序.gif)


## 三、选择排序

**思路：**

全部遍历找到最小值与第0个元素交换，再从第一个位置开始往后找到最小的，与第1个元素交换，再从第二个位置开始往后找到最小的与第2个元素交换，直到选到最后一个元素

**代码**

```java
 private static int[] selectedSort(int[] a) {
        for (int i = 0; i < a.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < a.length; j++) {
                if (a[minIndex] > a[j]) {
                    minIndex = j;
                }
            }
            int temp = a[i];
            a[i] = a[minIndex];
            a[minIndex] = temp;
        }
        return a;
    }
```

**动图**

![快速排序](常见算法排序/选择排序.gif)



## 四、堆排序

**动图**

![快速排序](常见算法排序/堆排序.gif)

## 五、冒泡排序

**思路**


**动图**

![快速排序](常见算法排序/冒泡排序.gif)


## 六、快速排序


**动图**

![快速排序](常见算法排序/快速排序.gif)


## 七、归并排序

**动图**

![快速排序](常见算法排序/归并排序.gif)

## 八、计数排序


**动图**

![快速排序](常见算法排序/计数排序.gif)
## 九、桶排序

**动图**

![快速排序](常见算法排序/桶排序.png)

## 十、基数排序

**动图**

![快速排序](常见算法排序/基数排序.gif)
